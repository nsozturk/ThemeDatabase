import type { BuiltArtifact } from '@/types/export';
import type { PlannedCatalog } from '@/exports/plan';
import { parseCssColor, rgbaToHexHash } from '@/lib/resolveColor';

export interface VimExportInput {
  filenameBase: string; // without extension
  mode: 'exact' | 'fallback';
}

function slugify(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50) || 'theme';
}

function hi(group: string, fg?: string, bg?: string): string {
  const parts = [`hi ${group}`];
  if (fg) parts.push(`guifg=${fg}`);
  if (bg) parts.push(`guibg=${bg}`);
  return parts.join(' ');
}

export async function buildVimArtifact(input: VimExportInput, planned: PlannedCatalog): Promise<BuiltArtifact> {
  const byKey = new Map(planned.plan.included.map((f) => [f.key, f.value] as const));
  const get = (key: string): string | undefined => {
    const raw = byKey.get(key);
    const parsed = parseCssColor(raw);
    if (!parsed) return undefined;
    if (parsed.a < 0.999) return undefined;
    return rgbaToHexHash(parsed);
  };

  const name = slugify(input.filenameBase);
  const lines: string[] = [];
  lines.push('" Generated by ThemeDatabase');
  lines.push('hi clear');
  lines.push('if exists("syntax_on")');
  lines.push('  syntax reset');
  lines.push('endif');
  lines.push(`let g:colors_name = "${name}"`);
  lines.push('');

  const normalFg = get('Normal.fg');
  const normalBg = get('Normal.bg');
  if (normalFg || normalBg) lines.push(hi('Normal', normalFg, normalBg));
  lines.push(hi('Comment', get('Comment.fg')));
  lines.push(hi('String', get('String.fg')));
  lines.push(hi('Number', get('Number.fg')));
  lines.push(hi('Statement', get('Statement.fg')));
  lines.push(hi('Function', get('Function.fg')));
  lines.push(hi('Identifier', get('Identifier.fg')));
  lines.push(hi('Type', get('Type.fg')));
  lines.push(hi('Operator', get('Operator.fg')));

  const visualBg = get('Visual.bg');
  if (visualBg) lines.push(hi('Visual', undefined, visualBg));

  const cursorFg = get('Cursor.fg');
  if (cursorFg) lines.push(hi('Cursor', cursorFg));

  const cursorLineBg = get('CursorLine.bg');
  if (cursorLineBg) lines.push(hi('CursorLine', undefined, cursorLineBg));

  lines.push('');

  const content = lines.filter(Boolean).join('\n') + '\n';
  return {
    target: planned.plan.target,
    filename: `${name}.vim`,
    blob: new Blob([content], { type: 'text/plain' }),
    mode: input.mode,
  };
}

